冗余、耦合度高
<JVM>
    堆首地址值 0x12ab
    可达性分析 GC Roots
    运行时数据区：
        ①程序计数器
         本地方法栈
         虚拟机栈 stack：方法内定义的变量 > 栈帧（先进后出）
        ②堆 heap：new出来的结构（比如：数组实体、对象的实体）。包括对象中的属性
         方法区 method area：存放类的模板。比如Person类的模板
    安全：
        双亲委派机制
    new一个对象的堆栈分配：
        声明对象    实例化对象
        Car car = new Car();
          栈          堆
<基础>
    程序设计思想：
        OOP 面向对象 Java ✔
        POP 面向过程 C语言
    java的8大基本数据类型：
        1、整型的byte、short、int、long；
        2、字符型的char；
        3、浮点型的float、double；
        4、布尔型的boolean。
    ==与equals：
        ==：
            在引用数据类型中比较的是地址，基本数据类型比较的是值
        equals：
            比较引用数据类型的值，比如“字符串比较”，一样的字符串返回的是true，基本数据类型不能用
            比较两个相同对象的话，返回的是false，需要在类中重写Object的equals()方法才能实现：
                手动自己实现/调用IDEA自动实现（推荐）
                *判断两个A对象是否equals()，除了A类需要重写equals()之外，其内部的类类型的属性所在的类，也需要重写equals()
    引用数据类型：
        数组、类、接口；记录（jdk14）、枚举（jdk5.0）、注解（jdk5.0）
    按照变量在类中声明的位置不同：
        1、成员变量
            ✔权限修饰符、默认初始值，
            存储在堆空间，
            对象创建而创建，
            对象消亡而消亡（属性/成员变量/field（字段/域））；
        2、局部变量
            ❌权限修饰符、默认初始值，
            存储在栈帧空间，
            入栈帧创建，
            出栈帧消亡（方法内、方法形参（方法传递中的变量）、构造器内、构造器形参（方法传递中的变量）、代码块内等）。
    权限修饰符：
        缺省、public公共的、protected受保护的、private私有的
    方法重载：
        同名方法，参数列表不同
    可变个数形参的方法：
        public void print(int ... nums){} for循环遍历nums int ... nums = int[] nums
        可传参方式：print(1,2,3) 或 print(new int[]{1,2,3})
        可变形参赋的实参个数可以为：0个、1个或多个
        可与其它方法构成重载
        特例：与对应的数组参数不构成重载 public void print(int[] nums){} ❌
        与其他形参共用时，只能写在最后，不可写在最前：public void print(int i, int ... nums){}
    方法的传递机制：
        值传递（数据值/地址值）
    递归（直接/间接）：
        方法自己调用自己的现象就称为递归
    javabean：
        类是公共的、有一个无参的公共的构造器、有属性，且有对应的get、set方法
    类的组成：
        字段（属性）、方法、构造器
    两个Date如何import使用：
        使用全类名的方式 java.sql.Date date =  new java.sql.Date date()
<面向对象>
    面向对象三大特征：
        ①封装：
            • 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
            • 低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用。
            如何实现数据封装？
                4种权限修饰符：public公共的、protected受保护的、缺省、private私有的
        ②继承：
            子类只能继承一个父类，需遵循is-a关系
            方法的重写：
                子类对父类中继承过来的方法进行覆盖、覆写的操作
                this、super
        ③多态：
            使用前提：
                ①要有类的继承关系
                ②要有方法的重写
            我需要一个宠物 > 我需要一只狗
            父类的引用指向子类的对象/子类的对象付给父类的引用（子类对象的多态性）
            虚拟方法调用/动态绑定（static静态方法都是静态绑定，静态方法不能被重写，多态都是动态绑定）：
                Person man = new Man();
                man.walk();
            适用与方法，属性不存在多态性
            在多态的场景下，我们创建了子类的对象，也加载了子类特有的属性和方法。但是由于声明的父类的引用，
            导致我们没有办法“直接”调用子类特有的属性和方法。
            没有办法“直接”调用，说明如果的确需要调用，也是有办法的：
                向上转型与向下转型（类似于基本数据类型的强转）
                Person man = new Man();
                Man m = (Man)man;//使用强转符
                (man == m) 返回true，返回的是同一个地址（指向堆空间中的同一个对象）
                建议在向下转型前，用instanceof进行判断，避免出现ClassCastException类型转换异常
                if(man instanceof Man){
                    //是就强转
                    Man m = (Man)man;
                }
    面向对象编程（高级）：
        class（类）中可以声明的结构：
            属性、方法、构造器；代码块/初始化块、内部类
        static：
            共享变量/静态变量，只能用在全局变量上，不可用在局部变量上
            单例模式（饿汉式-立即加载、懒汉式-延迟加载）
                区别：先new与后new的区别，可以从使用频率来选择，用的多就饿，用的少就懒
                优缺点：
                    饿汉式（推荐），线程安全，但内存中占用时间较长
                    懒汉式，线程不安全（多线程章节时解决），需要时进行创建，节省内存空间
        final：
            类不能被继承、方法不能被重写、变量变为常量（全局/成员变量）不能被赋值，常量名需大写
            修饰变量时：全局/成员变量和局部变量都可以使用
        abstract（抽象的，可以修饰类，也可以修饰方法）：
            抽象类必须要有子类
            继承extends抽象类的子类，必须重写父类中的抽象方法，否则报错/子类也需是抽象类
            定义一个abstract类：
                public abstract class Person {//抽象类
                    public abstract void eat();//抽象方法
                }
            抽象类不能实例化，父类只有方法签名，没有方法体，这种没有方法体的方法称为抽象方法。
            抽象类中是可以没有抽象方法的。反之，抽象方法所在的类，一定是抽象类。
            java语法规定，包含抽象方法的类必须是抽象类。
            模板方法的设计模式：
                能确定的父类实现，不确定的子类实现
            使用抽象类作为形参时，一定得用多态：
                父类 变量名 = new 子类对象;
                多态中的匿名对象，指的是没有声明变量名的对象，直接把new的对象当作参数放在形参里面
                    A.select(new Aa);
        interface：
            class A extends SuperA implements B,C{}
                A相较于SuperA来讲，叫做子类
                A相较于B,C来讲，叫做实现类
                类只能继承一个类，但能实现多个接口（一定程度上弥补了类的单继承的局限性）
            内部结构：
                可以声明：
                    属性：
                        必须使用public static final修饰全局常量
                        接口类中也可省略这三个修饰符，因为在接口类中声明的字段，默认就有这三个修饰，可以忽略不写
                    方法：
                        jdk8之前：抽象方法修饰为public abstract（抽象）
                            接口类中也可省略这二个修饰符，因为在接口类中声明的方法，默认就有这二个修饰，可以忽略不写
                        jdk8：声明静态方法、默认方法
                            静态方法：
                                可以在接口中添加有方法体的静态方法
                                只能通过接口直接调用里面的静态方法，实现类无法调用
                            默认方法：
                                public default void method(){}
                                接口中声明的默认方法，可以被实现类继承，也可以重写默认方法
                                如果类实现了两个接口，而两个接口中定义了同名同参数的默认方法，
                                则实现类在没有重写此两个接口默认方法的情况下，会报错。-->接口冲突
                                要求：此时实现类必须要重写接口中定义的同名同参数的方法。
                                重写后，相当于把两个接口中同名的方法一并重写了，就不会报错了。
                                子类（或实现类）继承了父类并实现了接口，父类和接口中声明了同名同参数的方法。
                                （其中，接口中的方法是默认方法）。默认情况下，子类（或实现类）在没有重写此方法的情况下，
                                调用的是父类中的方法。--->类优先原则
                                A.super.method();//调用接口A中的默认方法，super体现的不一定是父类的，
                                继承的父类，实现的接口都算是super的场景，都是基于实例来讲的
                        jdk9：声明私有方法
                            private方法就是给jdk8中的静态方法用的，用于抽取默认方法中公共的一些方法，不对外暴露
                不可以声明：
                    构造器、代码块等
            接口的继承关系：
                接口与接口之间可以多继承 interface C extends A,B{}
            接口的多态性：
                接口名 变量名 = new 实现类对象;
                还是虚方法的调用
            举个例子：
                比如电脑安装的驱动就是一套标准（接口）的实现类
        内部类：
            类A只会被类B调用/类B中有一个属性需要更丰富的对象才能表述，那么就可以抽取成一个内部类进行使用
            高类聚、底耦合：
                对内定义相关的结构，对外只提供需要的一些方法
            private、protected可以修饰成员内部类，也可以使用static修饰
            Person.Dog dog = new Person.Dog();

            Person p = new Person();
            Person.Dog dog = p.new Dog();

            Person.this.eat();
            String name = Person.this.name;

            接口匿名实现类的匿名对象：
                new A(){
                    public void method(){
                        System.out.println("method");
                    }
                }.method();
            提供一个继承于C的匿名子类的对象：
                C c = new C(){};
                c.method();
        枚举类enum：
            本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。
        注解annotation：
            可以进行验证
            框架 = 注解 + 反射 + 设计模式
            自定义注解：
                public @interface MyAnnotation{
                    String value() default "hello";
                }
        单元测试JUnit：
            黑盒测试：不看代码
            白盒测试：看代码，关注程序具体的执行流程，也需要写代码
        包装类/封装类：
            使基本数据类型有了类的特点，new后包了一下，把数据放在了堆中：
                Byte Short Interger Long Float Double > 都继承于number
                Boolean Character
            目的是为了使得基本数据类型的变量具备引用数据类型变量的相关特征（比如：封装性、继承性、多态性）。
            基本数据类型和包装类相互转换:
                （装箱）基本数据类型 > 包装类
                    int i1 = 10;
                    Interger ii1 = new Interger(i1);
                    System.out.println(ii1.toString());
                    Interger ii2 = Interger.valueOf(i1);
                    System.out.println(ii2.toString());
                （拆箱）包装类 > 基本数据类型
                    Interger ii3 = new Interger(10);
                    int ii4 = ii3.intValue();
                    ii4++;
                以上5.0开始就不用了，新特征：
                    自动装箱、自动拆箱（语法糖）：
                        自动装箱：基本数据类型 > 包装类
                            int i = 10;
                            Interger ii = i;
                            System.out.println(ii.toString());
                        自动拆箱：包装类 > 基本数据类型
                            int i2 = ii;
            String字符串引用类型：
                （装箱）基本数据类型 > 包装类:
                    String s = String.valueOf(10);// valueOf把所有基本数据类型转成String引用数据类型（字符串）
                    String s = 10 + "";
                （拆箱）包装类 > 基本数据类型：
                    int i = Interger.parseInt("123");
            java.util.Vector向量:
                Vector v = new Vector();
                int ii = 10;
                Interger i = Interger.valueOf(ii);
                v.addElement(i);/v.addElement(ii);//自动装箱
                System.out.println(v.size());
                System.out.println(v.elementAt(0));
                小技巧：
                    while(true){} 等同于 for(;;){}

<算法>
    杨辉三角、斐波那契（不死神兔）
    数组：特征值统计(平均值、最大值、最小值、总和等)、反转、扩容、缩容、
    回形数、线性查找（遍历）、牛顿二分法查找（仅支持有序数据，升降序都可以）
    衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性
    排序（10种，只关注3种）：堆排序、冒泡排序、快速排序（类似二分法）
<设计模式>
    代理模式：
        Thread中的run()方法调用就是用的代理模式
    单例模式：
        static的使用，共享变量/静态变量，只能用在全局变量上，不可用在局部变量上
        饿汉式-立即加载、懒汉式-延迟加载
    模板方法模式：
        能确定的父类实现，不确定的子类实现
    生产者与消费者模式：
        多线程、数据同步机制synchronized、wait等待、notify/notifyAll通知

<Debugger>
    强制退出，不走后面的所有逻辑:
        正常点击退出，后面的逻辑一样会走完，下面的方式可以在当前强制退出：
            右键 > Force Return

<UML类图>
    统一建模语言，用来描述软件模型和架构的图形语言































